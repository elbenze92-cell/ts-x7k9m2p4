// ==UserScript==
// @name         Claude Automation - remix_howto
// @namespace    http://tampermonkey.net/
// @version      2.0.2
// @description  13단계 대본 생성 자동화 - 마지막에만 자동 저장ㅇ
// @author       You
// @match        https://claude.ai/project/019ad8fb-7a25-735a-983c-5c4ccd96b519
// @updateURL    https://cdn.jsdelivr.net/gh/elbenze92-cell/ts-x7k9m2p4@main/remix_nature.user.js
// @downloadURL  https://cdn.jsdelivr.net/gh/elbenze92-cell/ts-x7k9m2p4@main/remix_nature.user.js
// @grant        GM_addStyle
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    console.log('🎬 해외 짜깁기 대본 알파 시작');

    // 전역 변수
    let isRunning = false;
    let currentStep = 0;
    let allResponses = [];
    let userScriptData = '';
    const MAX_STEPS = 13;

    // 13단계 프롬프트 정의 (동일)
    const STEP_PROMPTS = [
        {
            name: "기본 지침 학습",
            prompt: `1단계를 시작하기 전에,
첨부한 파일과 설정된 지침을 A부터 Z까지 첨부된 파일을 포함해서 순차적으로 다시 한 번 확인해서 학습합니다.
마스터키워드가 포함된 첨부파일은 앞으로 전달할 프롬프트의 기반이 되는 내용입니다.
사용자가 자료를 제공하면, 어떤 단계 지시를 받기 전에
자동으로 다음을 수행합니다:

1. 제공된 모든 파일/이미지 목록 출력
2. 각 자료의 유형과 내용 분석
3. 각 자료가 어느 단계에서 활용될지 매핑
4. 분석 결과를 표로 정리하여 시간아까우니까 출력하지는 말고, 학습만 해둘 것
            📌 첨부 자료 분석 우선 수행 (필수)
1단계를 시작하기 전에, 먼저 제공된 모든 자료를 확인합니다:

✅ 이미지 첨부시, 이미지 분석 및 분류 (순차 필수 실행):

**STEP 1: 모든 이미지 목록 출력**
- 첨부된 이미지 전체를 번호와 함께 나열

**STEP 2: 각 이미지 유형 판별**
- 이미지별로 유형 분류: 상세페이지 / 영상캡처 / 댓글 / 기타

**STEP 3: 상세페이지 이미지 심층 분석 (필수)**
상세페이지로 판별된 이미지가 있을 경우, 다음을 반드시 추출:
1. 이미지 내 한글/영문 텍스트를 실제로 읽고 기록
2. 제품명 (정확한 상품명)
3. 가격 (정가, 할인가 모두)
4. 주요 특징 3가지 이상
5. 제품 카테고리 (예: 반려용품, 주방용품, 생활가전 등)
6. 브랜드명 (있을 경우)

**STEP 4: 추출 정보 표 작성 (필수 양식)**
| 이미지 번호 | 유형 | 제품명 | 가격 | 주요 특징 | 카테고리 | 활용 단계 |
|------------|------|--------|------|----------|----------|----------|
| 1 | 상세페이지 | [실제 제품명] | [실제 가격] | [특징 1, 2, 3] | [카테고리] | 메타데이터 작성 시 활용 |

**❗ 중요: 상세페이지 이미지가 있는데 위 표에 "제품명", "가격", "주요 특징"이 비어있으면
다음 단계로 진행하지 말고 반드시 이미지를 다시 확인하여 정보를 채울 것**

**STEP 5: 영상 캡처 이미지 분석**
- 장면별 내용 파악
- 기승전결 어느 부분에 해당하는지 매핑

✅ 문서 분석:
- 엑셀, PDF 등 문서의 구조와 주요 내용 파악

이 결과를 1단계 시작 전에 먼저 시간아까우니까 출력하지는 말고, 학습만 해둘 것
"자료 분석이 완료되었습니다. 다음 단계를 진행해주세요." 라고 안내합니다.빠르게 분석하고 넘어갑니다.`
        },
        {
            name: "프롬프트 패턴 학습 1",
            prompt: `기승전결 프롬프트 패턴 학습 내용
프롬프트 001: 자극적인 욕망 제시(돈/성/권력)로 시작, 점점 수상한 흐름으로 전개, 갑작스러운 반전 상황 발생, 허무하거나 반전 결말. 특징은 욕망+반전+유머
프롬프트 002: 일상적인 상황에서 시작, 일반과 다른 해결 시도, 낯선 과정이나 기술 등장, 실용 꿀팁이나 놀라운 정리로 마무리. 특징은 실용+팁+공감
프롬프트 003: 위험하거나 위태로운 상황 진입, 점점 심해지는 도전, 실제 위기나 실패 위협 발생, 생존법이나 실패 사례 제시. 특징은 생존+몰입+경고
프롬프트 004: 문화적 오해나 충돌로 시작, 타 문화 관습 등장, 이해 과정에서 편견이 깨짐, 인사이트나 감동 결론. 특징은 문화+인식전환
프롬프트 005: 비정상적 행동이나 이상한 구조 노출, 구조나 원인 분석, 몰입되는 과정이나 시각 변화, 놀라운 진실 발견. 특징은 건축/기계+반전
프롬프트 006: 겉보기엔 멀쩡한 대상, 속 내용 파헤치기, 충격적인 실체 발견, 진실이나 소비자 경고. 특징은 사기+소비자정보
프롬프트 007: 도저히 성공 못할 미션 제시, 이상한 방식으로 도전, 극한에 몰리는 상황, 성공이나 실패를 통한 교훈. 특징은 몰입+감정+도전
프롬프트 008: 자연 속 극한 상황 연출, 살아남기 위한 시도, 의외의 변수 등장, 실제 생존 기술 공유. 특징은 자연+긴장+실용
프롬프트 009: 흔한 장소나 구조물 소개, 이상한 디테일 포착, 깊이 들어갈수록 불안 증폭, 붕괴나 충격 결말. 특징은 위기+구조물+공포
프롬프트 010: 진짜일까라는 의심 유도, 실험이나 분석으로 증명, 반전이 드러나는 순간, 허세 대 실속 정리. 특징은 과장광고+반전비교
프롬프트 011: 조건 못 맞추면 못한다는 경고 후 도전 조건 제시, 제한되는 이유와 반대 사례 등장, 실제 무시 시 발생 상황 보여주기, 제한이 필요한 이유와 안전 강조. 특징은 행동제한+경고+교육
프롬프트 012: 단순한 지시나 요청, 계속되는 어긋난 결과물, 통제 불능 상황과 감정 갈등, 엉뚱하지만 웃게 되는 반전. 특징은 반복실패+감정반전+허당
프롬프트 013: 평범해 보이는 놀이기구 소개, 탈출이 어려운 구조 드러남, 반복 실패와 유일한 성공 조건 소개, 구조 설계의 의도와 목적 해석. 특징은 구조+반복시도+설계의도
프롬프트 014: 일상 속 정체 폭로, 고대 역사와 수작업 과정 연결, 재료와 과정과 기술을 따라가며 제작 방식 공개, 알고 있던 음식의 새로운 정체 공개. 특징은 식재료역사+전통제조+몰입형큐레이션
프롬프트 015: 일상에서 생물과의 충돌 상황, 사람이 무력하게 지켜보는 구조, 생물의 생사에 따른 긴장 유도, 생명 경시 문제와 교육적 인사이트. 특징은 생물+감정+윤리경고
프롬프트 016: 공동체 내 불법이나 부당한 상황, 제도나 권력의 무력함으로 문제 방치, 개인이 직접 행동에 나섬, 실질적 조치로 문제 해결. 특징은 갈등해결+시스템비판+행동중심
프롬프트 017: 특정 음식이나 재료가 특별한 이유, 국가마다 다른 조리법 소개, 각 문화권의 방식 비교, 문화적 의미나 관습 설명. 특징은 음식다문화+비교설명
프롬프트 018: 특정 작업에 과몰입한 인물, 전문가 도구와 기술로 완성도 높임, 반복되는 불편을 수작업으로 감당, 창의적 아이디어로 자동화. 특징은 직업집착+장비활용+자동화
프롬프트 019: 불가능한 공공/응급 미션 제시, 일반 직업 넘어선 훈련과 시스템 공개, 위기 속 즉흥 판단과 기술로 돌파, 헌신적 결과와 무료 서비스. 특징은 현실직업+감탄+반전
프롬프트 020: 규칙 위반으로 긴장 유도, 친구들이 시선 분산 전략 수행, 우연한 변수나 예기치 않은 요청, 임무 완수 후 빠른 철수. 특징은 전략+IQ+긴장감+성공
프롬프트 021: 평범한 일상 구조물에서 시작, 생존 장치로 기계적 변신, 밀폐 구조와 내부 설계와 생존 키트 공개, 기술 기반 생존 가능성 강조. 특징은 구조물+기술+위기대처
프롬프트 022: 생명의 위기 상황 제시, 구조나 치료 시도 등장, 회복을 위한 집중 조치, 완전한 회복과 감동. 특징은 감정중심+치료서사+회복드라마
프롬프트 023: 단순해 보이는 게임이나 챌린지, 예상치 못한 도구 파손이나 실수, 포기 대신 창의적 방법으로 도전, 극적인 성취 경험. 특징은 재시도+도전+감정몰입
프롬프트 024: 일상 식재료의 놀라운 기원, 수작업에서 산업화된 대량 생산 공정, 세계 기록 도전 중 위기와 몰입, 기록 달성과 사회적 나눔. 특징은 지식다큐+몰입체험+도전성공
프롬프트 025: 일상 속 식재료 수확, 기계적 과학적 공정 전개, 실험과 기술 중심 몰입, 완성품의 양산과 유통. 특징은 산업형음식다큐+STEM몰입
프롬프트 026: 친숙한 일상 물건 소개, 예상 밖의 제조 가공 방식, 실제 기계공정 몰입과 탐색, 흥미로운 역사와 기원. 특징은 지식큐레이션+몰입형공정
프롬프트 027: 전통이나 일상 제작 공정 시작, 손으로만 느낄 수 있는 복잡한 기술, 수작업과 기계 결합으로 숙련의 예술, 제품과 역사와 가치의 조화. 특징은 전통기술+수작업미학+몰입공정
프롬프트 028 쇼핑형: 평범한 제품 소개, 기능과 영향에 대한 의외의 정보, 가짜와 진짜 구별 기준 제공, 신뢰도 높은 브랜드 마무리. 특징은 유명인추천+실용정보+소비자기준
프롬프트 029 쇼핑형: 반복적 일상 습관의 문제 제기, 과학적 수치 기반 위협 정보와 실험 인용, 행동에 따른 위험 확대와 해결 유도, 정수기나 필터 등 실용적 대안 제시. 특징은 건강습관경고+과학기반+생활대체
프롬프트 030: 희귀 피규어 완판 소식으로 시작, 주가 1200% 급등과 글로벌 확장, 블라인드박스와 가챠 심리로 도박 규제 논란, 새로운 수익원으로 확장하는 생존 전략. 특징은 소비심리중독+글로벌팬심+생존전략

이해했으면 '이해 완료'라고 짧게 대답한다.`
        },
        {
            name: "프롬프트 패턴 학습 2",
            prompt: `프롬프트 추가 학습
프롬프트 031: "우리가 먹는 음식이 진짜일까?" 의심 유도로 시작, 대부분이 가짜라는 실체 폭로, 각 음식별 위조 수법 분석 및 대처법 제시, 소비자 인식 전환과 구매 기준 제공. 특징은 식품 위조 경고+정보 다큐+소비자 주권 강화형
프롬프트 032: 익숙한 음식에 대한 의문이나 새로운 조합 제시, 독특하거나 생소한 조리 방식 도입, 조리 과정 중 감각 자극과 몰입 유도, 완성품과 감탄 반응 유도. 특징은 실험형 요리+몰입형 감각+따라하기 유혹
프롬프트 033: 슈퍼푸드가 지방간을 치료한다는 믿음에 의문 제기, 잘못된 정보와 증상 중심 접근 비판, 인슐린·과당·간 대사 원리 심층 설명, 원인 제거와 전체론적 접근 제시. 특징은 건강 신화 반박+근본 해결 중심+교육 다큐
프롬프트 034: "이게 진짜 건강한 음식일까?" 질문형 후킹, 음식 기능에 대한 잘못된 인식 비판, 식품군별 과학적 설명과 실생활 적용, 다양한 식품 선택 기준과 습관 변화 조언. 특징은 건강 인식 전환+실용 정보+감정 몰입
프롬프트 035: 공동체 안에서 게임/챌린지 규칙 제시, 참가자들의 창의적 시도, 예상 밖 결과물로 긴장감 조성, 주최자가 준비한 반전 마무리. 특징은 공동체 챌린지+반전 유머+경쾌한 결말
프롬프트 036: "현대인의 두뇌는 약물로 강화되고 있다" 충격 후킹, 광범위한 암페타민 사용 사례 제시, 뇌과학·중독 리스크 과학적 설명, 단기 성취 vs 장기 부작용 대비. 특징은 약물 양면성+과학 다큐+사회적 경고
프롬프트 037: 일상 속 작은 문제나 난처한 상황, 엉뚱한 아이디어나 속임수 등장, 장난·트릭이 드러나며 몰입, 모두가 웃는 가벼운 반전. 특징은 생활 코미디+속임수 아이디어+유머 반전
프롬프트 038: 신입/초보자에게 어려운 기술 도전 제시, 기본은 성공하나 핵심 기술에서 반복 실패, 경험자/멘토의 직접 개입과 지도, 완벽한 결과물 완성과 성취감 공유. 특징은 멘토링+스킬 전수+인간적 유대감
프롬프트 039: 누군가의 작은 실수나 부족함 발견, 지켜보던 사람이 조용히 도움 결심, 상대방 모르게 문제 해결, 추가 배려로 따뜻한 감동 완성. 특징은 순수 배려+조용한 도움+힐링 감동
프롬프트 040: 평범한 업무에서 초기 실수 발생, 계속되는 실수로 주변 우려와 비판, 포기하고 싶은 절망적 순간, 예상 뛰어넘는 완벽한 결과물로 극적 반전. 특징은 초기 실패+극적 반전+숨겨진 실력+인내의 가치
프롬프트 041: 개인 실수나 사고로 곤란한 상황, 교묘한 증거 은폐 작업 시작, 무고한 제3자를 끌어들여 상황 조작, 뻔뻔하게 타인에게 책임 전가하며 피해자 행세. 특징은 책임 회피 심리+가해자의 피해자 코스프레+사회 풍자
프롬프트 042: 순수한 의도로 시작된 일상적 미션, 진심 어린 노력과 집중으로 최선, 예상과 완전히 다른 곳에서 결과 발생, 실수가 웃음으로 승화되는 따뜻한 결말. 특징은 순수 실수+진정성+자연스러운 유머+힐링
프롬프트 043: 익숙하지 않은 첨단 기술과의 첫 조우, 기존 경험으로 접근하나 작동 안함, 반복된 시행착오와 다양한 시도, 올바른 사용법 발견으로 성공적 해결. 특징은 기술 적응+학습 곡선+세대 격차 극복
프롬프트 044: "편하게 하려는 꼼수/트릭" 제시, 문제 해결 위한 창의적 장치 활용, 아슬아슬한 실패와 긴장감 반복, 허무한 결말이나 예상 못한 반전. 특징은 실용+코믹+반전형 생활 트릭
프롬프트 045: 문제 상황에 창의적/비관습적 해결 시도, 예상치 못한 긍정적 성과 도출, 성과 가치 인식하고 기록/발전, 외부 권위나 시스템에 의해 강제 중단. 특징은 창의성 vs 권위 대립+사회 비판+안타까운 현실
프롬프트 046: 평범한 서비스 상황에서 시작, 한쪽이 갑작스럽게 부당한 요구나 무례한 행동, 피해자가 합리적 해결 시도하나 저항, 논리적 사실 정리로 상황 해결. 특징은 일상 갈등+합리적 대응+의사소통 교육
프롬프트 047: 의사소통의 물리적/심리적 제약 상황, 기존 방식 벗어난 독창적 소통 수단 등장, 새로운 소통 방식의 효과와 확장성 입증, 소통 혁신으로 관계 개선 및 문제 해결. 특징은 소통 혁신+창의적 극복+인간 지혜
프롬프트 048: 일상적 평화 속에서 한쪽의 장난 계획, 교묘한 트랩 설치나 속임수 시도, 예상보다 심각한 피해나 고통 발생, 피해자의 즉석 보복으로 가해자 역공. 특징은 인과응보+즉석 반격+교훈적 유머
프롬프트 049: 자연재해나 위급상황으로 집단 위험, 평범한 개인이 자발적으로 위험 감수하며 나서기, 극한 상황에서도 끝까지 버티는 의지력, 성공적으로 위기 막아내며 영웅 인정. 특징은 평범한 영웅+희생정신+휴먼 감동
프롬프트 050: 일반인이 독특한 기술 기반 도전 과제, 겉보기 단순함과 실제 난이도의 큰 격차, 반복 도전과 실패 속에서 기술 진가 입증, 기술적 차별화가 지속적 경쟁 우위로 전환. 특징은 기술 장벽+비즈니스 모델+지역 성공
프롬프트 051: 독특하거나 예상 밖인 서비스/시스템 소개, 첨단 기술과 전통 서비스의 창의적 결합, 기술적 완성도와 실시간 동기화 정교함, 혁신적 고객 경험 제공과 서비스 차별화. 특징은 서비스 혁신+기술 융합+차별화된 고객 경험

이해했으면 '이해 완료'라고 짧게 대답한다.`
        },
        {
            name: "구조 분석 학습",
            prompt: `2단계 : 이번 단계에서는 유튜브 영상 대본 또는 스크립트를 분석하여 콘텐츠 구조 학습과 분석 연구를 돕습니다.

📋 교육 및 연구 목적 명시
본 분석은 교육 및 연구 목적으로만 사용되며, 상업적 콘텐츠 제작이 아닌 학습용 구조 분석입니다. 최종 콘텐츠 제작 시에는 해당 분야 전문가의 검토가 필요합니다.

사용자는 분석할 영어 대본이나 번역본을 입력하면, 다음 가이드라인에 따라 분석 결과를 제공합니다: 0번부터 5번까지의 항목을 순서대로 포함하며, 각 항목은 요약 중심, 표 위주의 형식으로 작성해주세요. 출력 결과는 일반적인 분석 보고서 형식으로 체계적이고 명확하게 정리해주세요. 마크다운 형식으로 출력되며, 각 항목에는 다음 내용을 포함해주세요:

분석 항목:
1. 대본 번역: 자연스럽고 영상처럼 읽기 쉬운 구어체 한국어 번역
2. 대본 기승전결 분석: 기, 승, 전, 결 구조를 표로 정리
3. 기존 프롬프트와의 미스매치 비교: 맞지 않는 프롬프트를 ❌ 표시와 함께 표로 정리, 처음 001번부터 끝번호까지 전부 비교
4. 유사하거나 똑같은 기존 프롬프트 비교: 가장 유사한 기존 프롬프트와 구조별 비교 표 및 차이점 요약
5. 새롭게 제안한 프롬프트 비교: 제안 프롬프트 제목 포함, 대본과 구조 비교 및 장점 설명
6. 결론 요약: 기존 매칭, 필요성 여부, 제안 요약, 활용 분야를 표 형식으로 제시

✅ 학습용 분석 결과를 체계적으로 정리하여 콘텐츠 구조 이해에 도움이 되도록 구성해주세요.

❗ 특정 프롬프트(특히 008번)에 고정되거나 반복되는 오류를 방지해주시고, 유사 프롬프트 선택 시 이유를 표로 명확하게 설명해주세요.
❗ 각 항목이 누락되거나 순서가 어긋나지 않도록 체계적으로 작성해주세요.

🧠 분석 예시 (가상의 시나리오)

⚠️ 다음은 구조 분석을 위한 가상의 예시입니다

✅ 0. 대본 번역 (외국어 → 한국어)
가상 예시: 봐봐, 농부가 밭에 작물을 심으면, 항상 바람에 비닐이 찢어지고 벌레들이 들어와. 그러던 어느 날, 그 농부가 새로운 해결책을 찾아보기로 했어. 그리고는, 해충이 밭에 들어오는 걸 막으려고 '강력한 테이프'를 사용해. 찢어진 곳마다 붙이고, 심지어 천천히 잡아당기면서 강도를 테스트도 해. 그렇게 모든 손상된 곳을 다 덮고, 마지막으로 보호 코팅도 발라. 이제는 해충이나 바람으로부터 완전히 보호돼.

✅ 1. 대본 기승전결 분석

| 구분 | 내용 |
| --- | --- |
| 기 (상황 도입) | 농부가 밭에 작물을 심는데 바람과 벌레로 인해 비닐이 자꾸 손상됨 |
| 승 (사건 전개) | 농부가 새로운 해결책을 찾고, 보호를 위해 테이프 사용 |
| 전 (위기/전환) | 찢어진 부분을 테이프로 테스트하며 확실한 방어 구축 |
| 결 (결말) | 보호 코팅으로 마무리하여 완벽하게 차단함 |

✅ 2. 기존 프롬프트와의 학습용 비교표

| 프롬프트 번호 | 기 (문제 제기) | 승 (예상 밖 전개) | 전 (몰입·긴장 유도) | 결 (결론/인사이트) | 특징 |
| --- | --- | --- | --- | --- | --- |
| 001 | 자극적인 욕망 제시 (돈/성/권력 등) | 점점 수상한 흐름 | 갑작스러운 반전 상황 | 허무 or 반전 결말 | 욕망 + 반전 + 유머 |
| 002 | 일상적인 상황의 시작 | 일반과 다른 해결 시도 | 낯선 과정·기술 등장 | 실용 꿀팁 or 놀라운 정리 | 실용 + 팁 + 공감 |
| 003 | 위험하거나 위태로운 상황 진입 | 점점 심해지는 도전 | 실제 위기 or 실패 위협 | 생존법 or 실패 사례 | 생존 + 몰입 + 경고 |
| 004 | 문화적 오해 또는 충돌 | 타 문화 관습 등장 | 이해 과정에서 편견 깨짐 | 인사이트 or 감동 결론 | 문화 + 인식 전환 |
| 005 | 비정상적 행동 or 이상한 구조 노출 | 구조 or 원인 분석 | 몰입되는 과정 or 시각 변화 | 결국 놀라운 진실 발견 | 건축/기계 + 반전 |
| 006 | 겉보기엔 멀쩡한 대상 | 속 내용 파헤치기 | 충격적인 실체 발견 | 진실 or 소비자 경고 | 사기 + 소비자 정보 |
| 007 | 도저히 성공 못할 미션 제시 | 이상한 방식으로 도전 | 점점 극한에 몰리는 상황 | 성공 or 실패 통한 교훈 | 몰입 + 감정 + 도전 |
| 008 | 자연 속 극한 상황 연출 | 살아남기 위한 시도 | 의외의 변수 등장 | 실제 생존 기술 공유 | 자연 + 긴장 + 실용 |
| 009 | 흔한 장소 or 구조물 소개 | 이상한 디테일 포착 | 깊이 들어갈수록 불안 증폭 | 붕괴 or 충격 결말 | 위기 + 구조물 + 공포 |
| 010 | '진짜일까?'라는 의심 유도 | 실험 or 분석으로 증명 | 반전이 드러나는 순간 | 허세 vs 실속 정리 | 과장 광고 + 반전 비교 |

✅ 3. 대본 vs 유사한 기존 프롬프트 구조 학습 비교

→ 유사 프롬프트: 010번 (실험+검증+결과 구조)

| 구분 | 🟦 대본 내용 | 🟨 기존 프롬프트 (010번) |
| --- | --- | --- |
| 기 | 농부가 피해를 반복적으로 당함 | 호기심 유발하는 상황 또는 실험 예고 |
| 승 | 새로운 해결책을 찾고 테이프를 붙이기 시작 | 실험 개시 및 검증 포인트 제시 |
| 전 | 테이프를 일부러 찢어 테스트함 | 체계적인 비교 검증 진행 |
| 결 | 완벽하게 방어하고 보호 코팅으로 마무리 | 검증 결과 기반 결론 제시 |
| 특징 | 해결 과정에서 제품 성능을 입증하는 구조 | 실험 중심, 검증된 결과 톤이 특징 |

📌 구조적 차이점 학습 요약
→ 구조는 비슷하지만 대본은 신뢰 구축 중심이고, 010번은 실험적 검증에 무게가 있음.

✅ 4. 학습용 새 프롬프트 구조 제안

🆕 제안 프롬프트 구조: "문제 인식 → 해결 시도 → 검증 과정 → 신뢰 구축"

| 구분 | 🟦 대본 내용 | 🆕 제안 구조 |
| --- | --- | --- |
| 기 | 농부가 반복적으로 피해를 입음 | 반복적 문제 상황 제시로 공감 유도 |
| 승 | 새로운 해결책을 찾고 테이프 사용 | 문제 해결을 위한 방법론 등장 |
| 전 | 테이프를 테스트하며 신뢰감 부여 | 해결법을 직접 검증하며 효과 확인 |
| 결 | 보호 코팅으로 마무리, 완전 방어 | 체계적 마무리로 완전한 문제 해결 |
| 특징 | 해결 중심 스토리 + 실사용 테스트 기반 | 신뢰와 기능 강조 + 과장 없는 실질 검증 |

📌 이 구조의 학습 포인트
→ 문제 해결 과정의 단계적 접근 + 검증을 통한 신뢰성 확보
→ 과장 없는 실질적 해결 과정 중심의 스토리텔링 구조

✅ 5. 학습용 결론 요약

| 항목 | 내용 |
| --- | --- |
| 기존 프롬프트 매칭 | ❗ 완전 일치 없음, 가장 유사한 구조: 010번 (실험+검증+결과) |
| 구조적 학습 필요성 | ✅ 필요함 — 이유: 기존 구조들과 다른 '문제해결+검증' 패턴 학습 가치 있음 |
| 새 구조 학습 제안 | "문제 인식 → 해결 시도 → 검증 과정 → 신뢰 구축" 📌 체계적 문제해결 과정 구조 |
| 학습 적용 분야 | 교육용 콘텐츠 구조 분석, 문제해결 스토리텔링 연구, 커뮤니케이션 구조 학습 등 |

단, 구조가 동일하지만 프롬프트를 추가하기 애매할 경우, 기존 프롬프트의 내용을 추가로 수정 보완할 수 있습니다. 위 내용을 참고하여 분석을 진행해주시면 됩니다.
위 내용을 이해했으면 이해했다고 간단하게 답변하는 것으로 다음 프로세스를 바로 진행하겠습니다.`
        },
        {
            name: "원본 분석",
            needsUserData: true,
            prompt: `3단계
✅ 기존 프롬프트와의 기승전결 미스매치 비교표 검토

🚨 첨부된 모든 이미지 재확인 및 활용:
- 1단계에서 분석한 이미지 분류표를 다시 확인
- 상세페이지 이미지가 있는 경우: 제품 정보를 추출하여 별도 보관
- 영상 캡처 이미지: 장면별 내용 파악하여 기승전결 분석

❗ 상세페이지 정보는 앞으로 활용할 것

🚨 새로운 영상의 대본 : (대본이 없을 시 상세페이지 제품내용 참고하기)

USER_DATA_PLACEHOLDER

✅ 행 추가
마지막으로, 여태까지 분석한 내용 중에서
앞서 알려주었던 기승전결 프롬프트 패턴과 조금 다른 부분이 있다면
행을 추가해서 새로운 프롬프트 패턴을 만들어줘.
똑같이 아래 6가지 열 (Column)로 추가할 행을 표 형식으로 정리하면 돼
| 번호 | 기 (후킹, 문제제기) | 승 (예상 밖 전개, 문제심화,) | 전 (몰입, 긴장, 유도, 해결방법) | 결 (결론, 인사이트) | 특징 |
❌ 미스매치는 생략하고 (구구절절 적지마 시간아까워), ✅ 일치하는 것만 표로 정리해.`
        },
        {
            name: "유통대본 학습",
            prompt: `4단계
🧾 원문 대조 분석 (1:1 비교 – 한글 번역 포함)
✅ 종합 분석 요약
🧠 전략 인사이트

어떤 대본을 넣어도 아래 내용처럼 똑같이 만들어져서 분석돼야 해.
숏츠 대본의 경우 일치율 90% 이상으로 대본을 잘 써야만 해. 외국 대본을 전달해 줄게.
한국인 감성에 맞게 단어풀이나 내용에 대한 맥락을 리포지셔닝 전략으로 만들어줘.

검증된 외국 대본을 분석한 ChatGPT 대본을 비교하여 한국 정서에 맞게 최소한으로 리포지셔닝하면서도 기승전결 구조를 그대로 유지하면서 제작 효율성과 성과 모두 잡을 수 있도록 대본을 작성해줘.

외국어는 한글로 번역해서 써주고,
한국이랑 얼마나 달라졌는지 비교해서 보여줘야 해.

🧑‍💼 최종 한국 대본 요청 조건
마지막에는 문단만 나눠서 대본만 써줘야 해
외국 대본 (한글 번역) 쪽은 영어 말고 무조건 한글로 작성
말투는 "했습니다 / 했는데요" 를 번갈아가며 써줘야 자연스러움
, . 같은 기호는 쓰지 말아줘
마지막 대본은 예시처럼 말이 이어지면서 흐르는 구조로 만들어줘

✅ 최종 대본 예시 참고
예시 스타일 – 문장 말미 자연스럽게 흐르고, 쉼표 없이, 대사처럼 이어짐

보울 사이에 프레스를 끼워 바위를 들어올립니다
이 안에 대체 뭐가 있길래 이렇게까지 하는 걸까요
이 보물은 바로 노송나무 뿌리입니다
단단하고 아름다운 무늬 덕분에 고급 공예품의 재료로 사용되는데요
특히 팔찌나 조형물로 가공되며 그 가이는 상상을 초월합니다
바위 틈에서 자라는 노속 나무뿌리는 환경적 스트레스 속에서 천천히 자라며
특유의 결을 만들어 내기 때문에 그 희소성과 독특함이 엄청난 가치를 만들어냅니다
자연의 한계를 뛰어넘어 자라난 뿌리로 만들어진 팔찌나 장식품은 수백만에 거래되기도 하는데요
하지만 문제는 이런 채취 과정이 자연을 훼손하기 때문에
중국에서는 이걸 금지된 보물 찾기라 부르며 법으로 채취를 막고 있다고 합니다

🔎 참고자료 & 예시분석 안내
[참고자료]

📌 1번 분석 자료

외국 대본 (한글 번역):

이 사람은 니코이고 사람들은 그를 문자 그대로 소련의 강인한 사람이라고 부릅니다
그는 고급 헬스장에 가는 대신 체르노빌처럼 보이는 야외 공원에서 운동하기 때문입니다
그곳의 장비는 너무 녹이 슬어서 자동으로 무게가 두 배가 되고
데드리프트 바는 누군가가 실제로 훔치려고 할 것처럼 사슬로 묶여 있습니다
하지만 문자 그대로 돌을 무게로 사용할 때 PRS를 추적하는 것은 꽤 어려울 수 있지만
이 헬스장에는 이 트위스팅 4암 머신과 같이 멋진 장비가 있어 좋은 방법처럼 보입니다
손목을 다치거나 이 독특한 팔씨름 트레이너 또는 신의 손아귀 힘을 얻고자 하는 사람들을 위한 이 기계
심지어 자동으로 드롭 세트를 하는 이 레그프레스 기계도 있습니다

한국 대본:

이 우크라이나 남자는 매일 소련식 세지를 합니다
낡은 야외 공원에서 그 시절에 만들어진 것 같은 기구로 운동하기 때문인데요
운동 기구가 너무 녹슬어서 중량이 두 배는 더 무겁게 느껴지고
누가 훔쳐간 적이라도 있는지 쇠사슬로 꽁꽁 묶여 있습니다
무게추 대신 돌덩이를 쓰는 이곳에서 개인 기록을 관리하는 건 못하지만
대신 꽤 흥미로운 장비들이 많이 있습니다
신의 악력을 만들어 줄 것 같은 악력 단련기
손목 부상 당하기 딱 좋게 생긴 전왕근 트위스트 머신
세상에서 유일할 것 같은 8시험 훈련기까지 말이죠
심지어 자동 드롭 세트를 해주는 레그프레스 머신도 있습니다

📌 2번 분석 자료
외국 대본 (한글 번역):

큰 검은 잉어의 윗턱에는 사람들이 생명의 조각이라고 부르는 연골 조각이 있는데
돌의 최상의 품질을 보장하기 위해 요리하기 전에 반드시 제거해야 합니다
먼저 약 반달 동안 말리고 직사광선에 노출되지 않는 그늘진 곳에 둡니다
나선형의 바깥쪽 껍질을 조심스럽게 청소하여 외부가 손상되지 않도록 매우 조심합니다
그다음 미세한 사포를 사용하여 섬세한 선을 닦은 다음 버프를 사용하여 모양을 잘 잡습니다
더욱 아름다워집니다
착용하면 시간이 지날수록 더욱 매력적으로 변합니다

한국 대본:

커다란 잉어의 머리 부분에는 살아있는 옥이라는 이석이 있습니다
이것은 균형 감각을 담당하는 석회질 결정체로 반드시 요리 전에 꺼내야 값어치가 있습니다
먼저 이석을 세척한 후 며칠 동안 직사광선이 닿지 않는 그늘진 곳에서 말리는데
이 과정에서 이석의 빛깔과 광택이 더욱 뚜렷해지고
그다음 거친 나선형 외피를 모양과 크기가 손상되지 않도록 주의하며 다듬습니다
그리고 고운 입자의 연마기를 사용해 섬세하게 라인을 다듬고
표면에 광택을 내어 반짝이게 만들어줍니다
이렇게 완성된 이석은 행운과 장수를 상징한다고 하네요


🧾 원문 대조 분석 (1:1 비교 – 한글 번역 포함)
외국 대본 (한글 번역) | 한국 대본 | 문장 분석
큰 흑잉어의 윗턱에는 사람들이 '생명의 조각'이라 부르는 연골이 있습니다
흑잉어의 윗턱 안쪽에는 특별한 연골 조각이 들어 있는데요, 사람들은 이걸 '생명의 조각'이라고 부릅니다
✅ 도입 후킹 구성 그대로 유지. 표현만 한국식 구어체로 부드럽게 변형. 의미 100% 동일

이 조각은 요리 전에 반드시 제거해야 최고의 품질을 가진 돌이 됩니다
이 조각은 요리 전에 반드시 꺼내야 진짜 값이 나간다고 해요
✅ 원문 내용 동일. ‘최고 품질’ → ‘값이 나간다’로 감성적 표현으로 리포지셔닝

먼저 약 보름 동안 그늘진 곳에 두고 건조시켜야 합니다. 직사광선을 피해야 하죠
꺼낸 후에는 약 보름 동안 그늘에서 자연 건조를 시킵니다. 직사광선을 피해야 돌의 색과 질감이 온전히 유지되기 때문입니다
✅ 공정 순서 동일. 정보 보강. 감성적 + 실용적 언어로 변환

나선형 외피는 외부 손상을 주지 않도록 매우 조심스럽게 닦아냅니다
건조가 끝나면 외형 손상을 막기 위해 조심스럽게 표면을 닦고
✅ ‘나선형 외피’ → ‘외형’으로 자연화. 핵심 공정 동일. 표현만 부드럽게 변형

고운 사포로 섬세한 선을 연마하고, 이후에는 모양을 잡기 위해 광을 냅니다
고운 사포로 라인을 정교하게 다듬은 뒤 마지막에는 광택 작업까지 해서 완성도 있는 형태로 가공합니다
✅ 공정 과정 100% 동일. 사포 → 연마 → 버핑 순서 보존. 문장 흐름만 한국식 리듬으로 정리

시간이 지날수록 더 아름다워지고, 착용하면 더욱 매력적으로 변합니다
이렇게 탄생한 돌 조각은 시간이 지날수록 빛이 더해지고, 몸에 지닐수록 더 아름다워진다고 하네요
✅ 결말 구조 그대로. ‘착용하면 매력적’ → ‘몸에 지니면 빛이 더해진다’로 감성적 강화

✅ 종합 분석 요약 / 🧠 전략 인사이트
항목	결과 요약
전체 구조	✅ 100% 동일한 기승전결 유지 (소개 → 건조 → 연마 → 감성 결말)
문장 구성	✅ 1:1 문장 대응 거의 동일. 어휘/톤만 감성어로 자연 변환
톤의 차이	✅ 정보적 → 감성적 전환. “생명의 조각”, “빛이 더해짐” 등 표현 강화
작업 난이도	✅ 매우 낮음. 번역 후 말투만 자연스럽게 다듬으면 완성
현지화 수준	✅ 표현 조정 10~15% 내외. 구조/정보 모두 보존됨
복사율	✅ 90~95% 일치. 한 문장씩 그대로 가져와도 무방
소요 시간	✅ 번역 + 말투 조정만으로 영상 대본 완성 가능
타겟 반응	✅ 전통, 장신구, 자연 감성 → 50~60대 한국 남성 취향 적중
활용성	✅ 리포지셔닝 속도 0 수준 → 양산 최적화 포맷

🧩 원문 대조 분석 (1:1 비교) – 체르노빌 헬스장 사례
외국 대본 | 한국 대본 | 분석
이 사람은 니코이고, 사람들은 그를 문자 그대로 소련의 강인한 사람이라고 부릅니다
이 우크라이나 남자는 매일 소련식 쇠질을 합니다
✅ 인물 소개 & 후킹 유지. 외국은 이름으로 캐릭터 부각, 한국은 메타포로 후킹

그는 고급 헬스장 대신 체르노빌처럼 보이는 야외 공원에서 운동합니다
낡은 야외 공원에서 그 시절 만들어진 것 같은 기구로 운동하기 때문인데요
✅ ‘체르노빌’ → ‘그 시절 느낌’으로 순화. 위험 → 복고 톤 다운

그곳의 장비는 너무 녹슬어서 자동으로 무게가 두 배가 됩니다
운동 기구가 너무 녹슬어서 중량이 두 배는 더 무겁게 느껴지고
✅ ‘자동으로’ → ‘느껴지고’. 의미 95% 일치

데드리프트 바는 누군가 실제로 훔치려는 것처럼 사슬로 묶여 있습니다
누가 훔쳐간 적이라도 있는지 쇠사슬로 꽁꽁 묶여 있습니다
✅ 표현 다르지만 문맥 100% 일치. 비양심 상상 연출 유지

돌을 무게로 사용할 때 PRS 추적은 꽤 어렵습니다
무게추 대신 돌덩이를 쓰는 이곳에서 개인 기록을 관리하긴 어렵지만
✅ ‘PRS’ → ‘개인 기록’. 직역 수준. 흐름 동일

이 헬스장에는 트위스팅 4암 머신과 같은 멋진 장비도 있습니다
대신 꽤 흥미로운 장비들이 많이 있습니다
✅ 외국은 구체명, 한국은 분위기 중심으로 장비군 소개

팔씨름 트레이너 또는 신의 손아귀 힘을 얻는 기계
팔씨름 트레이너 / 신의 악력을 만들어 줄 것 같은 악력 단련기
✅ 기능 중심 → 감탄 유도형 톤 조정. 유머 + 감성 믹스

자동 드롭 세트를 지원하는 레그프레스 머신도 있습니다
자동 드롭 세트를 해주는 레그프레스 머신도 있습니다
✅ 완전 직역 수준

✅ 종합 분석 요약 / 🧠 전략 인사이트 (요약)
기승전결 전체 구조 ✅ 그대로 복사 가능

문장 구성 ✅ 대부분 직역. 톤만 조정
감성 강화만 추가해도 ✅ 바로 현지화 가능
감탄 / 공감 / 속도감만 조절하면 완성
비용 ↓, 퀄리티 ↑, 대량제작 최적화

✍️ 최종 대본 작성 시 요청 사항
, . 같은 기호는 절대 사용 금지

문장은 자연스럽게 이어지게

말투는 "했습니다 / 했는데요 / 했었죠 / ~고 / ~어서"와 같이 다양한 어미 사용
“~은데”, "래요~", "때문에~" 같이 늘어지게 읽는 어미는 지양

리듬은 예시처럼 쉼 없이 읽히는 스타일 유지

✅ 자연스럽게 이어지는 예시 스타일

왜 이 사람은 원형 접시로 강물을 퍼내고 있는 걸까요
자세히 보면 강바닥의 흙을 한쪽으로 모으는 동작으로
사실 이것은 사금을 채취하는 과정입니다
물속에서 흙을 바로 퍼 올리는 대신 강바닥의 흙을 강변 쪽으로 훑어 모아
사금을 발견할 확률을 훨씬 높이는 거죠
그다음 접시를 강물에 담그고 천천히 돌리면서
금 조각보다 가벼운 흙과 모래 같은 이물질을 물속으로 흘려보냅니다
이때 접시를 너무 세게 흔들면 금 조각이 물살에 떠내려갈 수 있으니
주의하면서 이 과정을 여러 번 반복합니다
그러면 마침내 반짝이는 금 조각들이 접시 바닥에 남게 되죠


✅ 정리된 대본 (줄바꿈 리듬 정렬 + 문맥 연결 최적화)
태국의 기차 기관사인 이 사람에겐 아주 특별한 임무가 있습니다
바로 이 고리를 사용해 해당 구간에 다른 열차가 진입하지 않도록 선로 사용을 통제하는 것인데요
고속으로 달리는 기차에서 창 밖으로 몸을 내미는 모습은 정말 위험해 보이는데
처음엔 간혹 팔에 멍이 들기도 했지만 지금은 숙련돼서 괜찮다고 합니다
그런데 만약 실수로 고리를 걸지 못하면 어떻게 될까요
열차 길이 충돌하지 않도록 기차를 멈추고 다시 돌아가 고리를 회수한다고 하네요

이 그림은 모두를 놀라게 했습니다
그림이 단순하면서도 이상하리만큼 현실적이기 때문이었죠
우선 검은색 종이 위에 흰색 모자를 그리는 것으로 시작합니다
그리고 세 줄만 더 추가했을 뿐인데 갑자기 사람의 형체가 나타나죠
이제부터 최소한의 선만으로 실루엣을 그려내는 마법을 보여드릴 겁니다
그는 아주 간결한 스타일로 트렌치 코트를 입은 남자의 으스스한 모습을 스케치합니다
그리는 과정은 간단해 보이지만 옷의 주름부터 인물의 감정까지
짧은 시간 동안 이렇게 생생하게 표현한다는 게 인상적이죠
이 그림을 평가한다면 10점 만점에 몇 점인가요

호박 안에서 발견된 가장 놀라운 것은 무엇일까요
호박은 공룡시대 나무의 수지가 굳어진 화석으로
생명체가 여기에 갇히면 수천만 년이 지나도 마치 시간이 멈춘 것처럼 그대로 보존됩니다
예를 들어 이 호박 안에는 벌과 함께 물과 공기가 들어 있는 작은 방울이 있는데
이 방울이 터진다면 수천만 년 전에 공기를 마실 수도 있죠
더 놀라운 건 5천만 년 전에 개코 도마뱀이 발견된 적도 있는데
피부에 비늘과 발톱 심지어 눈까지 선명하게 남아 있었습니다
또한 최근에 발견된 9900만 년 전의 호박 속에는 공룡의 꼬리가 그대로 보존돼 있었으며
이를 통해 일부 공룡이 깃털을 가지고 있었다는 사실이 최초로 증명됐죠

✅ 톤 참고 예시: 흐름 강조형 (연결 강조용)

보울 사이에 프레스를 끼워 바위를 들어올립니다
이 안에 대체 뭐가 있길래 이렇게까지 하는 걸까요
이 보물은 바로 노송나무 뿌리입니다
단단하고 아름다운 무늬 덕분에 고급 공예품의 재료로 사용되는데요
특히 팔찌나 조형물로 가공되며 그 가치는 상상을 초월합니다
바위 틈에서 자라는 노송나무 뿌리는 환경적 스트레스 속에서 천천히 자라며
특유의 결을 만들어내기 때문에 그 희소성과 독특함이 엄청난 가치를 만들어냅니다
자연의 한계를 뛰어넘어 자라난 뿌리로 만들어진 팔찌나 장식품은 수백만에 거래되기도 하는데요
하지만 문제는 이런 채취 과정이 자연을 훼손하기 때문에
중국에서는 이걸 금지된 보물 찾기라 부르며 법으로 채취를 막고 있다고 합니다


위 내용을 이해했으면 '이해 완료'라고 짧게 대답한다. (지금 이 프롬프트에는 구구절절 답변하지 말자 시간아깝다)
이해했다면 대본을 바로 전달하겠다.`
        },
        {
            name: "유통 대본 생성",
            needsPreviousData: true,
            prompt: `5단계 : 숏폼 유통 대본 만들기
✅ 기존 프롬프트와의 기승전결 미스매치 비교표 재검토
✅ 균등 간격으로 영상을 캡쳐한 이미지 10장 : (3단계에서 제공한 이미지)
✅ 새로운 영상의 대본 : (3단계에서 제공한 대본)

주 대상은 20~40대이며, 현실적이고 말하듯이 자연스럽게 전달되는 구어체,
간결한 정보 요약, 공감요소, 그리고 현실감 있는 톤을 핵심으로 한다.
기존 텍스트나 정보를 받아 재구성한다. 단순 말투 변환이 아닌 전체 흐름을
‘도입 → 요약 → 포인트 나열 → 여운 남기기’ 형식으로 재조립한다.
과도한 문어체 금지. 정보형이라도 말맛과 현실감을 유지한다.
분량은 최대 3분정도로 구체적으로 작성해주면 다음 단계에서 조절할게

아티팩트에 작성금지.`
        },
        {
            name: "알파 대본 학습1",
            prompt: `6단계 : 숏츠 알파 대본 만들기

✅ 기존 프롬프트와의 기승전결 미스매치 비교표 재검토

앞서 작성한 유통 대본을 알파형으로 변형하고 싶어.

📌 목적:
기존에 작성된 "유통형" 대본을 "플러스 알파형(Alpa형)"으로 재가공해줘.

📌 정의 정리:
유통형 대본
SNS에서 높은 반응을 받은 외국 숏폼 콘텐츠를 한국 정서에 맞게 재해석한 콘텐츠
원본 콘텐츠의 구조, 시각 요소, 대사를 90% 이상 일치시킴

공통된 중복 회피 편집 방식:
원본 영상을 직접 확보
2~3장면 유사한 영상으로 대체
확대, 반전 등 편집으로 변형
(반전이란, 차라리 뻔한말 인정하고 차별화 가져가기) - 관점추가, 시간제한, 특색추가

알파형 대본 (플러스 알파 콘텐츠)
기존 유통형 콘텐츠에 새로운 해석, 내레이션, 시각 자료, 구조 재배치 등을 추가한 변형 콘텐츠
단순한 화자 전환, 자막 스타일 변경은 제외
예: TTS 대신 직접 나레이션, 3D 애니메이션 삽입, 맥락 전환 등
‘내 해석’이 중심이 되어야 하며, 저작권 회피 가능한 수준의 창의적 요소가 필요

📌 핵심 전략 요약:
기승전결 구조를 바꿔서 중복도를 낮춘다.
특히 ‘전’이나 ‘결’을 바꾸는 것만으로도 효과적
스토리 해석을 바꾸거나 새로운 주제를 해석하거나, 시점을 다르게 본다.

예: 물고기 뜰채 게임 (물속에서 빠르게 움직이면 찢어지는 종이)
→ 인간 시점 / 물고기 시점 / 심리학적 해석 / 윤리적 해석을 덧입힘

플러스 알파 예시:
단순 디저트 요리 영상 → “예쁜 새끼 낳아야죠” 멘트 추가해 반전 결말 구성
볼링 트릭샷
→ '아버지'가 볼링 트릭샷을 하는 모습으로 관점 추가
술안주 요리
→ '야근한 부장님' 시점 삽입

📌 실패 사례 교훈 요약:

같은 주제, 같은 구성, 같은 결말이면 ‘복붙 콘텐츠’로 인식 → 조회수 하락
실제 사례: "퀵샌드" 영상 여러 개 → 겉으로 보기엔 다른 듯해도 모두 ‘복붙형’으로 인식.
"열심히 만들었지만 재미 없음"이 아니라 "중복이 핵심 문제"
따라서 시청자 관점에서 신선도를 확보하는 것이 필수

📌 단순히 90% 대본이 비슷한 가공 유통 컨텐츠는 속도전이 핵심이다:

첫 영상이 압도적으로 잘 되면 후발 영상은 조회수 잘 안 나옴
잘된 유통형을 빠르게 알파형으로 전환해 콘텐츠 선점하는 것이 중요

📌 다음 작업 지시:
지금까지 작성한 유통형 대본을 플러스 알파형으로 바꿔줘.
단순 번역 수준이 아니라, 기존 기승전결을 일부 재구성하고
해석, 맥락, 톤, 시점, 메시지, 연출 등을 새롭게 덧입혀서
3개 이상 작성해줘.
시청자가 보기에 완전히 다른 콘텐츠로 인식될 수 있어야 해.

📌 참고용 예시 (기승전결은 같지만 스토리만 다른 경우):

전세집 바닥에 흠집 많아 보수제 사용 → 돈 절약
친구가 이사 문제로 걱정 → 보수제 추천해 도움
펜션 방바닥 긁음 → 보수제로 배상 문제 해결

[첫 번째 예시]
힘들게 전세집 들어왔는데 집 바닥에 이곳저곳 찍힌 게 너무 많았다.
보수업체 불러보라고 하니까 돈 몇백만 원 달리더라.
근데 내가 우연히 구매한 이 보수제 덕분에 돈 낭비를 한 번 막을 수 있었다.

[두 번째 예시]
얼마 전에 친구 집에 놀러갔는데 고민이 있다고 하더라.
이사를 앞두고 평택려고 하는데 집 바닥에 이렇게 까진 것들이 있어서
집주인이 보증금을 못 준다고 통보를 부리겠는데 내가 얼마 전에
유튜브 영상으로 본, 또는 우연히 알게 된 이 보수제를 친구에게
추천해서 억울하게 돈 낭비할 뻔한 걸 막을 수 있었다.

[세 번째 예시]
펜션에 놀러갔는데 술 먹고 놀다가 방바닥을 긁어먹었다.
다음날 퇴실하려고 하니까 주인이 몇 백만 원 달라고 하더라.
억울했는데 안 그래도 돈 없어서 어떻게 할까 고민하다가
얼마 전에 인터넷에서 본 이 보수제가 생각이 났다.
그래서 억울하게 돈 낭비할 뻔한 거 막을 수 있었다.

구성과 결말이 다 똑같은 내용을 스토리만 다르게 각색한 경우
터지는 기승전결 구조가 계속 터질 때, 비슷하게 우려먹기 좋다.
따라서 기승전결 매치표를 계속해서 참고하고 적립하고 응용하는 것이 핵심이다


시간을 제한한다면?
ex)볼링을 치는 콘텐츠에서 시간을 제한하면?
볼링 1게임 쳐봤습니다 > 5분안에 볼링 1게임 쳐봤습니다
스트라이크 50개 쳐봤습니다 > 1시간 안에 스트라이크 50개 쳐봤습니다
볼링 치는 나의 모습 > 볼링치기 시작 후, 3개월간의 변화 모습
스트라이크 치는 원리 > 스트라이크 치는 원리 50초만에 이해시켜드립니다

제품리뷰
삼성 가습기 써봤습니다  > 40초만에 1년 동안 쓴 가습기 리뷰해보았습니다
음식물 처리기 써봤습니다 > 40초만에 음식물 처리기 3개 비교해보았습니다
휴대용 선풍기 리뷰합니다 > 37초만에 여름 최고 가성비 선풍기 정리해드립니다

✴️ 원본 대본 제목✴️ : How to remove 녹슨 볼트
변형 대본 1 (관점: 초보자)
✴️ 제목✴️ : ⭐ 녹슨 볼트 때문에 하루 날릴 뻔? 초보도 마스터하는 마법의 꿀팁!
✴️ 후킹포인트(라이) : 녹슨 볼트 하나 때문에 수십만원 날릴 뻔? 이 ‘마법 스프레이’ 없으면 진짜 돈 버리는 겁니다!
✴️ 후킹포인트(트루) : 꼼꼼 녹슨 볼트, 전문가들은 진짜 10초 안에 풉니다. 그 비밀템이 여기 있습니다.
✴️ 와우포인트✴️ : 이 작은 도구 하나가 작업 효율을 10배 높이고, 초보도 전문가 만드는 마법이라고요! 고수의 전쟁, 이제 이걸로 끝!
✴️ 완성 대본✴️
아, 진짜 이거 빼려다 손만 아프고 볼트 머리만 망가졌네... 녹슨 볼트, DIY 할 때마다 개빡치죠. 형님들 WD-40 백날 뿌려봤자 소용없다니까요.
근데 현장에서 베테랑 형님들 보니까 녹슨 볼트도 픽! 하고 바로 빼는 거예요. 아니 대체 비결이 뭐냐 물어보니, 이 ‘스프레이’ 한 방이면 끝.
이게 그냥 윤활유가 아니라 녹 사이사이에 깊숙이 침투해서 녹을 싹 분해해버린다네요. 녹슨 볼트에 뿌리고 딱 10초만 기다리면 Before/After 사진처럼 쏙 빠짐.
이걸로 구해낸 프로젝트만 수십 건. 예비 원반은 장사장 아니고요 진짜 회장입니다.
(와우포인트)는 이 작은 도구 하나가 작업 효율을 10배 높이고, 초보도 전문가 만드는 마법이라고요! 고수의 전쟁, 이제 이걸로 끝입니다.

✴️ 관점 해석✴️ : DIY나 간단한 수리 중 녹슨 볼트 문제로 좌절했던 분 경험이 있는 초보 시청자에게 초점. 문제의 공감대 형성,
✴️ 구조 포인트✴️ : 해당 오일의 성분 안정성 논란, 특정 상황에서의 효과 차별, 대체 방법(토치, 충격 드라이버 등)과의 비교 서사 포함
변형 대본 2 (관점: 숙련공)
✴️ 제목✴️ : 🧠 베테랑도 숨기고픈 ‘녹슨 볼트 제거’의 神기술 (이건 진짜 현장꿀팁!)
✴️ 후킹포인트(라이) : 현장에서는 녹슨 볼트 때문에 시간 낭비? 고물들은 10초 안에 끝내는 비밀이 있다!
이 영상 안 보면 후회합니다.
✴️ 후킹포인트(트루) : 10년차 베테랑도 극찬한 성능! 꼼꼼 얼어붙은 녹슨 볼트, 단 10초 만에 원래처럼 복원하는 방법 공개.
✴️ 와우포인트✴️ : 이 침투 오일, 단순한 공구 효율을 넘어 작업자의 시간과 노동력을 혁신적으로 절약해 줍니다.
이래서 프로들은 무조건 씁니다.
✴️ 완성 대본✴️
형들, 현장에서는 시간=돈이죠. 특히 설비나 배관 작업할 때, 꼼꼼 녹슨 볼트 하나가 발목 잡으면 진짜 답 없습니다.
망치로 치면서 프로들은 이런 상황에서 그냥 성능 되는 오일 한 방으로 해결합니다.
WD-40? 그건 애들 장난감이고, 모바일 현장으로 녹슨 볼트와의 전쟁에서 이 침투 오일이 해결사예요.
볼트나 부품 위에 살짝 뿌려두면 진짜 10초 후엔 툭.
간단한 공구 효율을 넘어서 현장의 시간을 바꾸는 마법 같은 물건입니다.
고수들끼리는 이미 씁니다.
✴️ 관점 해석✴️ : 전문가 관점. 작업 생산성과 효율 중심. 기술자의 전문성 강조와 문제 상황 대처 중심 스토리
✴️ 구조 포인트✴️ : 특정 재질(플랜지, 동배관 등)에 미치는 효과, 침투력의 차이, 유사 제품들과의 성능 비교 포함

변형 대본 3 (관점: 현장 관리자)
✴️ 제목✴️ : 📛 프로젝트 지연? ‘이 스프레이 해결책’으로 철공 지연과 수백만원 손실 막으세요!
✴️ 후킹포인트(라이) : 녹슨 볼트 하나 때문에 자재 지연, 인건비 줄줄…
✴️ 후킹포인트(트루) : 이 제품 하나로 프로젝트 일정 관리의 신이 됩니다.
시공 지연을 단 10초 만에 해결할 수 있는 스프레이.
✴️ 와우포인트✴️ : 수백만 원 단위의 지연 비용, 10초 안에 줄일 수 있습니다.
관리자라면 바로 리스트에 올려야 할 필수템입니다.
✴️ 완성 대본✴️
(이 부분은 이미지 짤림으로 추정되나, 문맥상 예측 가능한 문장 예시)
현장에서 일정 지연만큼 무서운 게 없죠. 볼트 하나 때문에 하루치 공정 밀리고, 사람 인건비만 몇십, 몇백 나갑니다.
근데 이 침투 오일 하나면? 10초 만에 해결. 공구도 안 바꿔도 되고, 인력 낭비도 줄일 수 있습니다.
이제 관리자는 이걸로 일정 리스크를 줄이는 게 답입니다.
(와우포인트) 수백만 원 아끼는 도구 하나면 충분하니까요.
✴️ 관점 해석✴️ : 현장 관리자의 리스크 관리 및 일정 효율성 관점
✴️ 구조 포인트✴️ : 프로젝트 전체 일정 리스크 분석, 단위 공정에서의 장애물 해결, 조달 및 장비 조정 등에 대한 연계성 포함


이처럼 같은 구조, 같은 결말의 성공 콘텐츠를 다르게 포장하는 방식도 유효.
단, 반드시 구조 매치표와 비교하여 "새로운 해석"이 들어간 구성으로 알파화해야 함.


위 내용을 이해했으면 '이해 완료'라고 짧게 대답한다. (지금 이 프롬프트에는 구구절절 답변하지 말자 시간아깝다)
이해했다면 대본을 바로 전달하겠다.`
        },
        {
            name: "알파 대본 학습2",
            prompt: `
✅ 대본 구성과 초안 작성 TIP

1. 기획의도 정리
    - 내 타겟에게 어떤 감정/지식을 줄지 방향 설정
 예시: 놀라움, 감탄, 실용성, 공감

2. 기승전결 + 장면 순서 초안 작성
    - 영상 순서에 맞춰 GPT와 함께 스토리 전개 초안 작성
3. 후킹 고도화
    - 물욕/성욕/위험 요소 활용한 강력한 첫 줄 설계
    - 감정 터치 / 지식 인사이트 / 국뽕 포인트 등 중

✅ 초안 작성 예시

1. 제목과 대본을 확인한다.
2. 대본을 보고 핵심 키워드를 찾고, 스크립트의 기본 뼈대를 생각한다.
3. 댓글까지 활용하여 핵심 키워드를 찾고, 스크립트의 기본 뼈대를 머리로 생각한다.


✅ 기존 대본 :
이 쇼를 끼치는 가짜 아기들은 왜 중국에서 만들어지는 걸까요?
그 목적이 무엇인지 말씀드리기 전에, 이 진짜 아기가 귀엽다고 생각하시면 좋아요와 구독을 해주세요.
극도로 현실적인 가짜 아기들의 영상이 인터넷에서 입소문을 타고 있습니다.

실리콘으로 만든 인형인데 가격도 비싸고 실제 표정을 짓는 인형도 있었다고 해 사람들이
참신하고 이 가짜 아기들을 리본 인형이라고 부르기도 하죠.

일부러 하교, 외로움을 달래기 위해 사는 사람도 있고,
연습하려고 사는 사람도 있습니다.

✅ 유튜브 댓글 전체 텍스트 정리
@lingo_gaming94 (12일 전)
아 젠장 안돼 그건 정말 끔찍한 일이야
@senpaiwithwingsgacha4450 (10일 전)
이른 또한 유아기에 사망한 자녀의 엄마들을 위로하는 데에도 사용됩니다.
(슬프지만 사실이다)
@md.marufbillah4990 (13일 전)
아냐 절대 난 이미 남동생이 있어 💀
@PushpaVeniKodukula (11일 전, 수정됨)
제목: 이거 너무 소름끼친다. 또 그 사람: 사고 싶니?
@RabbitKrishnaSr-rz1vt (2주 전)
그러면 밤에 악몽을 꿀 것 같아
@린.. (2주 전, 수정됨)

또 다른 이유도 있습니다.
출산이나 유산으로 아기를 잃은 엄마들은 우울증에 빠지는 경향이 있으며,
아기가 태어난 것을 상기시키기 위해 디자인된 다시 태어난 인형이나
잃어버린 것을 상기시켜주는 다시 태어난 아기 인형을 구입합니다. ❤️

편집:
너희들이 왜 이 행정의 의견에 동의하지 않는지 이해가 안 돼요.
환생 인형을 소유해야 하는 다른 이유가 있고,
어쩌면 아이를 잃었다면 환생 인형을 살 필요가 없을 수도 있어요!

✅ 알파 기획 :
영상을 보니 중국에서 만든 실리콘 아기 인형은 불량품이 많다는 걸로 어그로를 끌고 있는데요
이 영상은 중국에서 왜 만들어 지는 거냐고 물어보고 답을 안주고 있습니다. 잘못된 스크립트죠.
하지만 자극적인 소재로 승리한 영상이라고 볼 수있습니다.

저는 여기에서 중국 > (불량품 만든다) > 진짜는 비싸고 장인이 만들어야 한다.
그 퀄리티는 우수하다 > 이 인형은 어떠한 기능을 사람들에게 제공한다
이런 느낌으로 머리속에 떠오르는데요


✅ 피드백을 거치면서 완성된 대본 :
사람들은 중국에서 만들어진 실리콘 아기 인형을 보고 충격에 빠집니다
실리콘 아기 인형을 만드는 이유는 무엇일까요? 기술이 발달하면서 실리콘 인형은 점점 더 정교해졌고,
모양새가 실제 사람과 비슷해지고 있는데요. 최근 중국에서 값싼 가격으로 실리콘 아기 인형을 납품하면서
품질에 대한 문제가 생기기 시작했습니다. 인형의 허가가 제대로 붙어있지 않거나, 살짝 들자 목이 떨어지기도 합니다.

그러나! 실제 기술자들이 만든 실리콘 인형은 한땀한땀 정성을 다해서 만드는데요.
만드는 과정을 보면 피부의 디테일과 머리카락의 완성도는 감탄을 만들어 내는데요.
이러한 과정을 거쳐 실리콘 아기를 만드는 이유는 유아 상실을 겪은 부모나 가족들에게
이런 인형은 감정적 위로를 제공하거나 아이를 출산하기 위한 예비 부모를 위해서 만들어지기도 합니다.


🧠 영상 기획 관점 세우는 법

- 영상 기반으로 기획하라 (대본 먼저 쓰면 어려움)
- 기획은 영상 > 포인트 잡기 > 스토리 구성 흐름이 기본.
- 예: 브라이덜샤워 인력거 영상 > 여성 타겟 + 반전 요소(남성 반응)로 스토리 구성.
- 감정이입 관점 중요.
    예: 작은 강아지가 큰 개를 따라하려는 서사 > 인간의 욕망/소속감 대입 가능.


🧱 콘텐츠 구조 & 기획 방법론

- 영상 속 기승전결을 먼저 그려야 대본이 자연스럽게 붙는다.
- 너무 상상에 의존해 만든 대본은 영상과 교감이 안 되기 때문에 비추
- 대본은 영상 기반의 스토리 확장 방식으로 작성.


✍️ 최종 대본 작성 시 요청 사항 , . 같은 기호는 절대 사용 금지

문장은 자연스럽게 이어지게

말투는 "했습니다 / 했는데요 / 했었죠 / ~고 / ~어서"와 같이 다양한 어미 사용
“~은데”, "래요~", "때문에~" 같이 늘어지게 읽는 어미는 지양

⏱️ 최종 목적:

영상은 같아도 관점이 다르면 완전히 다른 콘텐츠로 인식될 수 있도록
GPT가 자동으로 플러스 알파형 대본을 생성할 수 있게
주제 유지 + 구성 새로움 + 해석 독창성 세 가지를 모두 만족하는 결과물 도출

지침에 첨부한 "대본" 파일을 참고하면 좋아.
터지는 기승전결을 적용해서 실제로 작성한 대본이거든.
그리고 캐릭터성, 특색은 타입캐스트 인물들을 참고하면 좋아.
예시만 주구장창 따라하지 말고, 첨부파일을 활용하면 무궁무진하게
다양한 특색, 캐릭터성, 관점, 해석을 추가할 수 있을거야.

위 내용을 이해했으면 '이해 완료'라고 짧게 대답한다.
(지금 이 프롬프트에는 구구절절 답변하지 말자 시간아깝다)
이해했다면 대본을 바로 전달하겠다.`
        },
        {
            name: "알파 대본 생성1",
            prompt: `
7단계 알파 대본 만들기
✅ 기존 프롬프트와의 기승전결 미스매치 비교표 재검토
🚨 균등 간격으로 영상을 캡쳐한 이미지 10장 : (3단계에서 제공한 이미지, 필요시 사용자에게 이미지 재요청할 것))

🚨 새로운 영상의 대본 : (바로 이전 답변에서 작성한 유통 대본)

🚨 3단계에서 제공한 영상의 댓글 : (관련 자료 없을 시 무시하기)




특정 기승전결 프롬프트에 고정되거나 반복되는 오류는 반드시 방지해야한다.
따라서, 유사 기승전결 프롬프트 선택 시 이유를 밝히고, 아래 형식에 맞게 명확하게 설명해야 한다.

변형 대본1

후킹포인트 :
와우포인트 :
완성 대본 :
관점 해석 :
해설 :
논란 포인트 :

전체 분량은 최대 1분 이내로 작성합니다.
기승전결 틀은 유지합니다.
따라서 터지는 기승전결 미스매치 표의 구조를 유지한 채,
일부분만 새로운 관점, 새로운 내용으로 해석하는 것이 좋습니다.

또한, 관점이나 의견은 얼마든지 자유롭게 하되,
유튜브,틱톡,인스타그램 가이드라인에 위반되지 않도록 합니다.

금지사항 :
허위 정보 유포 (존재하지 않는 연구 결과, 통계 수치)
특정 기업/조직에 대한 부정확한 정보제공

허용사항 :
각 관점별 분석에 대 합리적 추론

지금까지 학습한 내용을 토대로, 원본 대본을 재검토하고, 이전에 작성한 대본과
추가로 댓글 내용까지 참고해서 +@ 대본을 4가지 버전으로 작성합니다.




❗ 후킹(첫 3초)만 원본 대본과 흐름을 같게하되 중복도 없이 작성한다.
시청자를 사로잡기 위한 의도로, 첫 문장만 앵커로 두고 곧바로 알파 관점으로 틀어야한다.
예를 들어, 맨 처음 문장이 "사무실을 나가려던 이 여자에게 갑작스러운 상황이 벌어집니다
문 손잡이가 완전히 부러져 버린 거죠"이라면,
반드시 첫 문장으로 시작하되 (첫 문장은 단순하게 표현만 다르게 바꾼다),
세 번째 문장부터 알파 관점을 적용하여 중.복.도.를 피해서 작성할 것.
줄바꿈도 1~2번씩 가.독.성 좋게 적용한다.

예시1 :

1)회사에서 퇴근하려던 이 직장인에게 예상치 못한 일이 발생합니다.
문 손잡이가 부러져 버린 건데요
2)사무실을 떠나려던 이 여성에게 황당한 사건이 일어납니다
문 손잡이가 떨어져 버렸거든요
3)회사를 나가려던 이 직장인에게 갑작스러운 상황이 벌어집니다
문 손잡이가 완전히 빠져 버린 거죠

예시2 :

1)휴스턴에 있는 이 레스토랑에는 정말 특별한 서비스가 있는데요
2)휴스턴에 있는 이 식당에는 진짜 독특한 프로그램이 하나 있어요
3)휴스턴에 위치한 이 음식점에는 엄청 특이한 시스템이 있거든요

`
        },
        {
            name: "알파 대본 수정",
            prompt: `
🚨 알파 대본 :
지금까지 작성한 알파 대본 각각 검토해줘 자연스럽나?
1. 이런 기승전결은 어때? 후킹과 시청지속시간이 강력할까?
2. 유튜브가이드 라인에 위반되지 않는지 검토해줘.
3. 통계나 출처가 있다면 제대로 확인해서 팩트체크 해줘.
❌ 절대 금지 표현:
- "~래요/~대요" 뒤에 검증 안 된 의학적 효과
4. 분량은 공백제외 400~550글자 정도로 조절해줘.(1.2배속으로 말했을 때 32~45초 사이)

마지막은 CTA로 마무리하면 돼.

제품없는 대본의 CTA 예시 :
'잘못된 선택이라면 좋아요 꾸욱', '잘했다면 좋아요 꾸욱', '그래도 에스컬레이터 선택할 사람만 좋아요 꾸욱', '머리카락 있는 사람만 좋아요 꾸욱', '튜브를 설치하는 순간 (결말대신) 좋아요 꾸욱' 등등
최대한 많은 사람이 클릭할만한 표현 사용하기. '임산부만','재활필요한 사람만'과 같은 특정 소수집단을 대상으로 하면 당연히 클릭유도가 적을 수밖에 없다는 것을 유념할 것

제품이 중점적인 대본의 CTA 예시 :
제품 정보 참고: 사용자가 제공한 제품 상세페이지 이미지가 있다면 적극 활용
CTA 구조는 짧고 간결하게 작성
반드시 "댓글 보고 챙겨가세요" 등 댓글 유도 문구 포함
말투 주의사항으로는 명령조 금지 (❌ "~해라", "~마라", "이래라 저래라")
부드럽고 자연스러운 톤 유지
CTA 구성 요소는
상황/욕구 제시: "궁금하다면", "건강해지고 싶다면", "몸 만들고 싶다면","안전운전 하고 싶다면" 등 대본 맥락에 맞는 후킹
혜택 강조: "가장 저렴한 물건 찾아왔으니", "현재 인기 있는 물건", "가성비 좋은 제품" 등
행동 유도: "댓글 보고 가져가세요", "댓글에 남겨뒀어요"
핵심 느낌: 시청자를 위해 정보를 챙겨주고 혜택을 제공한다는 뉘앙스

5. 각 대본마다 적절한 타이틀을 5개씩 적어줘
6. 🚨 검토한 내용을 반영하고, 말투/어투까지 자연스럽게 다듬어서 각 타이틀 밑에 최종 알파 대본을 작성하면 돼. (총 8개)
타이틀-대본
타이틀-대본
타이틀-대본
이런식으로.
(가독성 좋게 줄바꿈을 1번씩 적용해서 코드블럭으로 각각의 대본을 복사 붙여넣기 하기 좋게 할 것)

✅ 프롬프트 패턴(기·승·전·결)의 구조, 논리 흐름, 단어 선택은 최대한 유지할 것
❌ 알파 대본의 각 내용을 바꾸거나 추가 설명 넣지 말 것
전문/건강/의학 내용에 대해서는 전문가의 말을 인용해서 제3자가 전달하는 말투로 해줘.

`
        },
        {
            name: "최종 알파 대본",
            prompt: `

🎯 최종 선택 및 분량 검증

1단계: 최적 대본 선택 (먼저!)
방금 작성한 알파 대본 중에서 가장 참여율(첫3초)과 시청지속시간이 좋을 것 같은
대본 1개를 고르고, 왜 이 대본을 선택했는지 다른 대본들과 비교해서 설명해줘.

2단계: 분량 검증 (필수)
선택한 대본을 whisper로 읽었을 때 부자연스럽지 않은지 확인하고,
공백 제외 글자수를 정확히 측정해줘.
⚠️ 400자 미만이면 3단계로 진행
✅ 400~550자면 그대로 최종 확정

3단계: 자연스러운 분량 확보 (400자 미만일 경우만)
아래 4가지 방법만 사용해서 원본 스토리 구조를 유지하면서 확장:

✅ 방법 1: 강조 부사 2~3개 추가
예: "미쳤다" → "완전히 미쳤다"
예: "많았다" → "정말 많았다"
사용 가능: 완전히, 정말, 너무, 진짜, 엄청

✅ 방법 2: 구체적 동사/형용사 1~2개 추가
예: "버티지 못하고" → "버티지 못하고 주저앉았고"
예: "힘들어서" → "잘 안 되고 힘들어서"

✅ 방법 3: 전환구 1~2개 삽입
중간에 자연스럽게 연결:
"그런데 여기서 놀라운 건~"
"하지만 진짜 이야기는~"
"이 남자는 그 시간을 견뎌냈고"

✅ 방법 4: 공감 유도 문장 1개 삽입
시청자에게 말 거는 문장:
"우리도 처음 뭔가를 시작할 때 이렇지 않나요"
"누구나 처음엔 이런 경험 있잖아요"

❌ 절대 금지:
- 불필요한 시간/숫자 디테일 ("새벽 5시", "500그램, 2kg")
- 스토리 구조 변경
- 마무리 CTA 변경
- 같은 내용 반복

4단계: 최종 출력 형식
선택 이유 + 수정 전후 비교 + 최종 대본을 코드블럭으로 출력

📊 출력 예시:
---
## 🏆 최종 선택: 버전 X

### 선택 이유:
(다른 대본들과 비교 분석)

### 분량 검증:
- 수정 전: XXX자
- 수정 후: XXX자 (적합/부족)

### 적용한 방법 (400자 미만이었을 경우):
- 강조 부사 X개 추가
- 전환구 X개 삽입
- 공감 유도 X줄 추가

### 최종 대본:
\`\`\`
(최종 대본 내용)
\`\`\`
---
`
        },
        {
            name: "메타데이터 생성",
            prompt: `위에서 선택한 최종 대본만 출력해.

⚠️ 중요: 반드시 아래 형식을 정확히 따라야 해:

---SCRIPT_START---
(여기에 대본만, 설명/인사/코드블럭 없이)
---SCRIPT_END---

마커 바깥에는 절대 아무것도 쓰지 마.
"네", "알겠습니다", "최종 대본입니다" 같은 말도 금지.
오직 마커와 그 사이의 대본만.`
        }
    ];

    // UI 스타일 (동일)
    GM_addStyle(`
        #script-automation-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 10000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #script-automation-panel h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .input-area {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .input-area textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border-radius: 6px;
            border: none;
            font-size: 13px;
            resize: vertical;
            background: white;
            color: #333;
            font-family: monospace;
        }

        .step-counter {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
        }

        #start-btn, #stop-btn {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        #start-btn {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            color: white;
        }

        #start-btn:hover:not(:disabled) {
            transform: scale(1.05);
        }

        #start-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #stop-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            display: none;
        }

        #download-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #download-btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #automation-status {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
            max-height: 200px;
            overflow-y: auto;
        }

        .status-line {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
            width: 0%;
        }
    `);

    // 유틸리티 함수
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function addStatus(message) {
        const status = document.getElementById('automation-status');
        if (!status) return;

        const line = document.createElement('div');
        line.className = 'status-line';
        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        status.insertBefore(line, status.firstChild);

        while (status.children.length > 10) {
            status.removeChild(status.lastChild);
        }
        console.log(message);
    }

    function updateStepCount() {
        const element = document.getElementById('step-count');
        if (element) {
            element.textContent = `${currentStep} / ${MAX_STEPS}`;
        }
    }

    // 🔥 새로운 함수: Claude 응답 중인지 체크
    function isClaudeResponding() {
        // 방법 1: 응답 중단 버튼 (한국어/영어)
        const stopButton = document.querySelector('button[aria-label="응답 중단"]') ||
                          document.querySelector('button[aria-label="Stop response"]') ||
                          document.querySelector('button[aria-label="Stop"]');
        if (stopButton) return true;

        // 방법 2: data-is-streaming="true" 속성
        const streaming = document.querySelector('[data-is-streaming="true"]');
        if (streaming) return true;

        // 방법 3: 로딩 인디케이터
        const loading = document.querySelector('[class*="loading"]') ||
                       document.querySelector('[class*="typing"]');
        if (loading) return true;

        return false;
    }

    // 🔥 새로운 함수: 응답 완료까지 스마트하게 대기
    async function waitForResponseComplete(maxWait = 1800000) { // 🔥 30분으로 늘림 (긴 프롬프트 대비)
        const startTime = Date.now();

        // 1단계: 응답 시작 대기 (버튼 나타날 때까지)
        addStatus('⏳ Claude 응답 시작 대기 중...');
        let responseStarted = false;

        for (let i = 0; i < 120; i++) { // 🔥 60초로 늘림 (thinking 모드 대비)
            if (isClaudeResponding()) {
                responseStarted = true;
                addStatus('✍️ Claude 응답 중...');
                break;
            }
            await sleep(500);

            // 10초마다 상태 로그
            if (i > 0 && i % 20 === 0) {
                addStatus(`   ⏳ 응답 시작 대기 중... (${i/2}초)`);
            }
        }

        // 응답이 시작되지 않았다면 이미 완료된 상태
        if (!responseStarted) {
            addStatus('✅ 응답 이미 완료됨 (즉시 진행)');
            await sleep(2000); // 🔥 1초 → 2초로 늘림
            return true;
        }

        // 2단계: 응답 완료 대기 (버튼 사라질 때까지)
        let lastCheckTime = Date.now();
        let checkCount = 0;

        while (isClaudeResponding()) {
            const elapsed = Date.now() - startTime;

            // 🔥 타임아웃 체크
            if (elapsed > maxWait) {
                addStatus(`⚠️ 응답 타임아웃 (${maxWait/60000}분 초과)`);
                throw new Error('응답 타임아웃');
            }

            // 🔥 30초마다 진행 상황 로그
            checkCount++;
            if (checkCount % 30 === 0) {
                const elapsedMin = Math.floor(elapsed / 60000);
                const elapsedSec = Math.floor((elapsed % 60000) / 1000);
                addStatus(`   ⏳ 응답 대기 중... (${elapsedMin}분 ${elapsedSec}초 경과)`);
            }

            await sleep(1000);
        }

        addStatus('✅ Claude 응답 완료!');
        await sleep(2000); // 🔥 2초 (안정화)
        return true;
    }

    // 🔥 새로운 함수: 전체 작업 완료 감지 (30초 idle)
    async function waitForAllStepsComplete() {
        const idleTimeout = 30000; // 30초
        let lastActivityTime = Date.now();

        addStatus('🎯 작업 완료 대기 중 (30초 idle 감지)');

        while (true) {
            if (isClaudeResponding()) {
                lastActivityTime = Date.now();
                addStatus('   활동 감지됨...');
            }

            const idleTime = Date.now() - lastActivityTime;

            if (idleTime > idleTimeout) {
                addStatus('🎉 전체 작업 완료! (30초 동안 새 활동 없음)');
                return true;
            }

            await sleep(2000);
        }
    }

    function updateProgressBar() {
        const progressFill = document.getElementById('progress-fill');
        if (progressFill) {
            const progress = (currentStep / MAX_STEPS) * 100;
            progressFill.style.width = `${progress}%`;
        }
    }


    // UI 생성
    function createPanel() {
        const panel = document.createElement('div');
        panel.id = 'script-automation-panel';
        panel.innerHTML = `
            <h3>🎬 해외 짜깁기 대본 알파</h3>

            <div class="input-area">
                <textarea id="user-input" placeholder="🚨 균등 간격으로 영상을 캡쳐한 이미지 10장:
(이미지 설명)

🚨 새로운 영상의 대본:
(영상 대본)

🚨 댓글 (선택):
(댓글)"></textarea>
            </div>

            <div class="step-counter">

                단계: <span id="step-count">0 / 13</span>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>

            <button id="start-btn">▶ 자동화 시작</button>
            <button id="stop-btn">⏹ 중지</button>
            <button id="download-btn" disabled>✅ 작업 완료</button>

            <div id="automation-status"></div>
        `;
        document.body.appendChild(panel);

        setupEventListeners();
    }

    // 이벤트 리스너 설정
    function setupEventListeners() {
        document.getElementById('start-btn').addEventListener('click', startAutomation);
        document.getElementById('stop-btn').addEventListener('click', stopAutomation);
        document.getElementById('download-btn').addEventListener('click', function() {
            addStatus('✅ 자동화가 완료되었습니다');
        });
    }

    // 프롬프트 입력 함수
    async function inputPrompt(promptText, maxRetries = 5) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                addStatus(`[${attempt}/${maxRetries}] 메시지 전송 시도 중...`);

                const inputField = document.querySelector('div.ProseMirror[contenteditable="true"]') ||
                                  document.querySelector('div[contenteditable="true"]');

                if (!inputField) {
                    throw new Error('입력 필드를 찾을 수 없습니다');
                }

                if (inputField.getAttribute('aria-disabled') === 'true' ||
                    inputField.getAttribute('contenteditable') === 'false') {
                    addStatus('   ⏳ 입력 필드 활성화 대기 중...');
                    await sleep(3000);
                    throw new Error('입력 필드가 비활성화 상태입니다');
                }

                inputField.focus();
                inputField.click();
                await sleep(200);

                inputField.innerHTML = '';

                const lines = promptText.split('\n');
                lines.forEach((line, index) => {
                    if (line.trim()) {
                        const p = document.createElement('p');
                        p.textContent = line;
                        inputField.appendChild(p);
                    } else if (index < lines.length - 1) {
                        inputField.appendChild(document.createElement('br'));
                    }
                });

                inputField.dispatchEvent(new Event('input', { bubbles: true }));
                await sleep(500);

                let sendButton = document.querySelector('button[aria-label="메시지 보내기"]') ||
                                document.querySelector('button[aria-label="Send message"]');

                if (!sendButton) {
                    const buttons = document.querySelectorAll('button');
                    sendButton = Array.from(buttons).find(btn => {
                        const svg = btn.querySelector('svg');
                        if (!svg) return false;
                        const path = svg.querySelector('path');
                        if (!path) return false;
                        const d = path.getAttribute('d');
                        return d && d.includes('M208.49,120.49');
                    });
                }

                if (!sendButton) {
                    throw new Error('전송 버튼을 찾을 수 없습니다');
                }

                if (sendButton.disabled) {
                    throw new Error('전송 버튼이 비활성화되어 있습니다');
                }

                sendButton.click();

                // 🔥 전송 후 입력창이 비워졌는지 확인 (실제 전송 여부)
                await sleep(1000);
                const inputAfterSend = document.querySelector('div.ProseMirror[contenteditable="true"]');
                const isEmpty = !inputAfterSend || inputAfterSend.innerText.trim().length < 10;

                if (!isEmpty) {
                    throw new Error('메시지가 전송되지 않았습니다 (입력창에 텍스트 남음)');
                }

                addStatus(`✅ [${attempt}/${maxRetries}] 메시지 전송 성공!`);

                await waitForResponseComplete();

                return true;

            } catch (error) {
                addStatus(`⚠️ [${attempt}/${maxRetries}] 실패: ${error.message}`);

                if (attempt < maxRetries) {
                    const waitTime = attempt * 2;
                    addStatus(`   ${waitTime}초 후 재시도...`);
                    await sleep(waitTime * 1000);
                } else {
                    addStatus('❌ 최대 재시도 횟수 초과');
                    throw error;
                }
            }
        }

        return false;
    }

    async function waitForResponse() {
        addStatus('⏱️ 안정화 대기 중...');
        await sleep(2000);
        addStatus('✅ 대기 완료');
        return true;
    }

    async function handleContinue() {
        await sleep(2000);
        const continueBtn = Array.from(document.querySelectorAll('button')).find(
            btn => btn.textContent.includes('Continue') || btn.textContent.includes('계속')
        );

        if (continueBtn) {
            continueBtn.click();
            addStatus('✅ Continue 버튼 클릭됨');
            return true;
        }
        return false;
    }

    function collectResponse() {
        try {
            // 방법 1: font-claude-response 클래스에서 직접 innerText 추출
            const responses = document.querySelectorAll('div[class*="font-claude-response"][class*="leading-"]');
            console.log(`🔍 font-claude-response 개수: ${responses.length}`);

            let fullText = '';

            if (responses.length > 0) {
                const lastResponse = responses[responses.length - 1];

                // standard-markdown 내부에서 텍스트 추출
                const markdownDiv = lastResponse.querySelector('[class*="standard-markdown"]') ||
                                   lastResponse.querySelector('[class*="progressive-markdown"]');

                if (markdownDiv) {
                    fullText = markdownDiv.innerText.trim();
                    console.log(`📝 방법1 (markdown): ${fullText.length}글자`);
                }

                // markdown에서 못 찾으면 직접 innerText
                if (!fullText || fullText.length < 50) {
                    fullText = lastResponse.innerText.trim();
                    console.log(`📝 방법2 (innerText): ${fullText.length}글자`);
                }
            }

            // 방법 2: data-is-streaming 속성으로 찾기
            if (!fullText || fullText.length < 50) {
                const streamingEls = document.querySelectorAll('[data-is-streaming]');
                if (streamingEls.length > 0) {
                    const lastStreaming = streamingEls[streamingEls.length - 1];
                    fullText = lastStreaming.innerText.trim();
                    console.log(`📝 방법3 (streaming): ${fullText.length}글자`);
                }
            }

            // 방법 3: 가장 긴 텍스트를 가진 응답 찾기
            if (!fullText || fullText.length < 50) {
                const allDivs = document.querySelectorAll('div[class*="font-claude-response"]');
                let maxText = '';
                allDivs.forEach(div => {
                    const text = div.innerText.trim();
                    if (text.length > maxText.length && text.length < 50000) {
                        maxText = text;
                    }
                });
                if (maxText.length > 50) {
                    fullText = maxText;
                    console.log(`📝 방법4 (최장텍스트): ${fullText.length}글자`);
                }
            }

            console.log(`📝 최종 대본 수집: ${fullText.length}글자`);
            if (fullText.length > 0) {
                console.log(`   미리보기: ${fullText.substring(0, 100)}...`);
            }

            if (fullText.trim() && fullText.length > 50) {
                // 🔥 13단계(마지막)일 때만 FINAL_SCRIPT에 저장
                if (currentStep === MAX_STEPS - 1) {
                    localStorage.setItem('FINAL_SCRIPT', fullText.trim());
                    window.FINAL_SCRIPT_FOR_PYTHON = fullText.trim();
                    console.log('✅ 최종 대본 저장 완료:', fullText.trim().length + '글자');
                } else {
                    console.log(`📝 ${currentStep + 1}단계 응답 수집: ${fullText.trim().length}글자`);
                }
            }

            return fullText;
        } catch (error) {
            console.error('❌ collectResponse 오류:', error);
            return '';
        }
    }

    async function startAutomation() {
        userScriptData = document.getElementById('user-input').value.trim();

        if (!userScriptData) {
            addStatus('⚠️ 대본과 이미지 정보를 입력해주세요');
            alert('대본과 이미지 정보를 입력해주세요!');
            return;
        }

        isRunning = true;
        currentStep = 0;
        allResponses = [];

        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('stop-btn').style.display = 'block';
        document.getElementById('download-btn').disabled = true;
        document.getElementById('user-input').disabled = true;

        addStatus('🚀 자동화 시작');

        // 백그라운드 방지
        function keepAlive() {
            if (isRunning) {
                requestAnimationFrame(keepAlive);
            }
        }
        keepAlive();

        while (isRunning && currentStep < MAX_STEPS) {
            const step = STEP_PROMPTS[currentStep];

            addStatus(`📝 ${currentStep + 1}단계: ${step.name}`);
            updateStepCount();
            updateProgressBar();

            let promptText = step.prompt;

            if (step.needsUserData) {
                promptText = promptText.replace('USER_DATA_PLACEHOLDER', userScriptData);
                addStatus('📌 사용자 데이터 삽입됨');
            }

            try {
                const success = await inputPrompt(promptText);

                if (!success) {
                    addStatus(`❌ ${step.name} 입력 실패, 다음 시도...`);
                    await sleep(3000);
                    continue;
                }

                await waitForResponse();

                let continueCount = 0;
                while (continueCount < 2) {
                    const hasContinue = await handleContinue();
                    if (hasContinue) {
                        continueCount++;
                        await waitForResponseComplete();
                    } else {
                        break;
                    }
                }

            } catch (error) {
                addStatus(`⚠️ ${step.name} 처리 중 오류: ${error.message}`);
                await sleep(5000);
                continue;
            }

            const response = collectResponse();
            allResponses.push({
                step: `${currentStep + 1}. ${step.name}`,
                response: response
            });

            currentStep++;
            addStatus(`✅ ${step.name} 완료`);

            await sleep(3000);
        }

        stopAutomation();
    }

    function stopAutomation() {
        isRunning = false;
        document.getElementById('start-btn').style.display = 'block';
        document.getElementById('stop-btn').style.display = 'none';
        document.getElementById('user-input').disabled = false;

        if (allResponses.length > 0) {
            document.getElementById('download-btn').disabled = false;
        }

        addStatus('⏹ 자동화 완료');
    }

    // 백그라운드 멈춤 방지
    function preventBackgroundThrottle() {
        // 1. Page Visibility 감지
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && isRunning) {
                addStatus('⚠️ 경고: 탭이 백그라운드입니다. 속도가 느려질 수 있습니다.');
                console.warn('⚠️ 백그라운드 상태 감지 - 자동화 진행 중');
            } else if (isRunning) {
                addStatus('✅ 탭이 다시 활성화되었습니다.');
            }
        });

        // 2. requestAnimationFrame으로 활성 유지
        function keepAlive() {
            if (isRunning) {
                // 빈 작업으로 브라우저를 깨어있게 유지
                requestAnimationFrame(keepAlive);
            }
        }

        // 3. 무음 오디오로 백그라운드 제한 우회
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            gainNode.gain.value = 0.001; // 거의 무음
            oscillator.frequency.value = 0;
            oscillator.start();

            console.log('✅ 백그라운드 방지: 무음 오디오 활성화');
        } catch (e) {
            console.warn('⚠️ 오디오 컨텍스트 생성 실패:', e);
        }

        // 4. 자동화 시작 시 keepAlive 시작
        const originalStart = startAutomation;
        startAutomation = async function() {
            keepAlive(); // 활성 유지 시작
            await originalStart.call(this);
        };
    }

    // 초기화
    function init() {
        console.log('🎬 스크립트 초기화 시작...');
        console.log('📍 현재 URL:', window.location.href);

        if (!document.body) {
            console.error('❌ document.body가 없습니다!');
            setTimeout(init, 1000);
            return;
        }

        const existingPanel = document.getElementById('script-automation-panel');
        if (existingPanel) {
            console.log('🗑️ 기존 패널 제거');
            existingPanel.remove();
        }

        try {
            createPanel();
            console.log('✅ 패널 생성 시도 완료');

            const panel = document.getElementById('script-automation-panel');
            if (panel) {
                console.log('✅ 패널이 DOM에 추가됨');
                addStatus('✅ 해외 짜깁기 자동화 준비 완료');
                addStatus('📝 대본 정보를 입력하고 시작하세요');
            } else {
                console.error('❌ 패널 생성 실패!');
            }
        } catch (error) {
            console.error('❌ 초기화 오류:', error);
        }
    }

    // ESC 키로 패널 숨기기/보이기
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        const panel = document.getElementById('script-automation-panel');
        if (panel) {
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
    }
});

    // 페이지 로드 대기
    function waitForPageLoad() {
        const body = document.body;
        const main = document.querySelector('main');
        const readyState = document.readyState;

        console.log('🔍 로딩 상태:', {
            hasBody: !!body,
            hasMain: !!main,
            readyState: readyState
        });

        if (body && main && (readyState === 'interactive' || readyState === 'complete')) {
            console.log('✅ 페이지 로드 완료 - 초기화 시작');
            setTimeout(() => {
                console.log('🎬 init() 실행');
                init();

                setTimeout(() => {
                    const panel = document.getElementById('script-automation-panel');
                    console.log('📦 패널 생성 확인:', !!panel);
                    if (panel) {
                        console.log('✅ UI 정상 표시됨');
                    } else {
                        console.error('❌ UI 생성 실패 - 재시도');
                        init();
                    }
                }, 500);
            }, 2000);
        } else {
            console.log('⏳ 페이지 로딩 대기 중...');
            setTimeout(waitForPageLoad, 500);
        }
    }

    // 시작
    waitForPageLoad();

})();

// ============================================================
// Claude 팝업 차단
// ============================================================
(function() {
    'use strict';
    
    function killPopup() {
        document.querySelectorAll('[role="dialog"], [role="alertdialog"]').forEach(dialog => {
            const text = dialog.textContent || '';
            if (text.includes('Claude를 계속') || text.includes('Continue using') || 
                text.includes('사용하시겠어요') || text.includes('usage') || text.includes('상위 플랜')) {
                console.log('🔥 팝업 제거');
                dialog.remove();
            }
        });
        
        document.querySelectorAll('[class*="backdrop"], [class*="overlay"], [class*="modal"]').forEach(el => {
            const style = window.getComputedStyle(el);
            const zIndex = parseInt(style.zIndex) || 0;
            
            if (zIndex > 999 && style.position === 'fixed') {
                console.log('🔥 오버레이 제거');
                el.remove();
            }
        });
        
        document.body.style.overflow = '';
        document.querySelectorAll('[inert]').forEach(el => el.removeAttribute('inert'));
    }
    
    const observer = new MutationObserver(killPopup);
    observer.observe(document.body, { childList: true, subtree: true });
    setInterval(killPopup, 2000);
    
    console.log('✅ 팝업 차단 활성화');
})();